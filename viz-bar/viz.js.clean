// üìä Bar Chart with Color Field - WORKING SOLUTION
// Using the REAL Looker Studio API patterns discovered in 2024

console.log('üöÄ Bar Chart Loading...');

function drawViz(data) {
  console.log('üéØ drawViz called with data:', data);
  
  // Get or create container (same as test viz)
  let container = document.getElementById('container');
  if (!container) {
    console.log('üì¶ Creating container element...');
    container = document.createElement('div');
    container.id = 'container';
    container.style.width = '100%';
    container.style.height = '100%';
    document.body.appendChild(container);
  }
  
  // Clear any existing content
  container.innerHTML = '';

  try {
    console.log('üîç Data type:', typeof data);
    console.log('üîç Data keys:', data ? Object.keys(data) : 'data is null');
    console.log('üîç Data.dataResponse exists:', !!data?.dataResponse);

    // Extract data - handle the REAL Looker Studio format!
    if (data && data.dataResponse && data.dataResponse.tables && data.fields) {
      console.log('üéâ Found REAL Looker Studio data format!');
      
      // Extract data from data.dataResponse.tables[0].rows (the REAL path!)
      const rows = data.dataResponse.tables[0].rows;
      const fieldIds = data.dataResponse.tables[0].fields;
      
      console.log('üìä Raw rows:', rows);
      console.log('üìä Field IDs:', fieldIds);
      
      // Create field mapping from IDs to names using data.fields
      const fieldsMap = {};
      data.fields.forEach(field => {
        fieldsMap[field.id] = field.name;
      });
      console.log('üìä Fields map:', fieldsMap);
      
      // Convert row arrays to objects with field names
      const tableData = rows.map(row => {
        const rowObj = {};
        fieldIds.forEach((fieldId, index) => {
          const fieldName = fieldsMap[fieldId];
          rowObj[fieldName] = row[index];
        });
        return rowObj;
      });
      
      console.log('üìä Converted table data:', tableData);
      
      // Create field mappings by concept type for flexible field access
      const fieldMappings = {
        dimensions: [],
        metrics: [],
        allFields: {}
      };
      
      data.fields.forEach(field => {
        fieldMappings.allFields[field.name] = field;
        if (field.concept === 'DIMENSION') {
          fieldMappings.dimensions.push({ id: field.id, name: field.name });
        } else if (field.concept === 'METRIC') {
          fieldMappings.metrics.push({ id: field.id, name: field.name });
        }
      });
      
      console.log('üîç Field mappings:', fieldMappings);
      console.log('üîç Available dimensions:', fieldMappings.dimensions.map(d => d.name));
      console.log('üîç Available metrics:', fieldMappings.metrics.map(m => m.name));
      
      // Bar chart specific field access - same pattern as working test viz
      const categoryField = fieldMappings.dimensions[0]?.name;  // X-axis (dimension)
      const valueField = fieldMappings.metrics[0]?.name;        // Bar height (metric)
      const colorField = fieldMappings.dimensions[1]?.name;     // Color grouping (color)

      console.log('üìä Bar chart fields:', { 
        category: categoryField, 
        value: valueField, 
        color: colorField 
      });

      if (!categoryField || !valueField) {
        container.innerHTML = `
          <div style="padding: 20px; color: #d93025; border: 1px solid #d93025; border-radius: 4px; font-family: Arial, sans-serif;">
            <h3>‚ö†Ô∏è Missing Required Fields</h3>
            <p>Bar chart requires:</p>
            <ul>
              <li><strong>Category Field (Dimension):</strong> ${categoryField ? '‚úÖ ' + categoryField : '‚ùå Not configured'}</li>
              <li><strong>Value Field (Metric):</strong> ${valueField ? '‚úÖ ' + valueField : '‚ùå Not configured'}</li>
              <li><strong>Color Field (Dimension):</strong> ${colorField ? '‚úÖ ' + colorField : '‚ö†Ô∏è Optional'}</li>
            </ul>
            <p>Available fields:</p>
            <ul>
              <li><strong>Dimensions:</strong> ${fieldMappings.dimensions.map(d => d.name).join(', ') || 'None'}</li>
              <li><strong>Metrics:</strong> ${fieldMappings.metrics.map(m => m.name).join(', ') || 'None'}</li>
            </ul>
            <p>Please configure your fields in Looker Studio.</p>
          </div>
        `;
        return;
      }

      // Render the bar chart!
      renderBarChart(tableData, categoryField, valueField, colorField);

      console.log('‚úÖ Bar chart rendered successfully');

    } else {
      console.log('‚ö†Ô∏è No recognizable data format found');
      console.log('‚ö†Ô∏è Full data structure:', JSON.stringify(data, null, 2));
      
      container.innerHTML = `
        <div style="padding: 20px; color: #ea4335; border: 1px solid #ea4335; border-radius: 4px; font-family: Arial, sans-serif;">
          <h3>‚ùå No Data Available</h3>
          <p>Unable to find chart data in the expected format.</p>
          <details>
            <summary>Technical Details</summary>
            <pre style="font-size: 12px; overflow: auto; max-height: 200px;">${JSON.stringify(data, null, 2)}</pre>
          </details>
        </div>
      `;
    }

  } catch (error) {
    console.error('‚ùå Error in drawViz:', error);
    container.innerHTML = `
      <div style="padding: 20px; color: red; border: 1px solid red; border-radius: 4px;">
        <h3>‚ùå Visualization Error</h3>
        <p>Unable to render bar chart: ${error.message}</p>
        <details>
          <summary>Technical Details</summary>
          <pre style="font-size: 12px; overflow: auto;">${error.stack}</pre>
        </details>
      </div>
    `;
  } finally {
    // CRITICAL: Signal to Looker Studio that rendering is complete
    if (window.google && window.google.lookerstudio && window.google.lookerstudio.done) {
      window.google.lookerstudio.done();
      console.log('üì° Signaled rendering complete to Looker Studio');
    }
  }
}

function renderBarChart(tableData, categoryField, valueField, colorField) {
  console.log('üé® Rendering clean bar chart...');
  
  const container = document.getElementById('container');
  
  // Set fixed, good-looking dimensions
  const containerWidth = 800;
  const containerHeight = 500;
  
  // Chart dimensions with margins for labels
  const margin = { top: 40, right: 60, bottom: 80, left: 100 };
  const chartWidth = containerWidth - margin.left - margin.right;
  const chartHeight = containerHeight - margin.top - margin.bottom;
  
  console.log('üìê Chart dimensions:', { chartWidth, chartHeight });

  // Create clean HTML structure
  container.innerHTML = `
    <div style="
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      width: ${containerWidth}px;
      height: ${containerHeight}px;
      padding: 20px;
      box-sizing: border-box;
      background: #ffffff;
      border: 1px solid #e0e0e0;
      border-radius: 8px;
      margin: 20px auto;
    ">
      <h3 style="
        margin: 0 0 20px 0;
        color: #202124;
        font-size: 18px;
        font-weight: 500;
        text-align: center;
      ">üìä ${categoryField} vs ${valueField}</h3>
      <div id="chart-container" style="
        width: 100%;
        height: calc(100% - 60px);
        position: relative;
        overflow: hidden;
      "></div>
    </div>
  `;

  const chartContainer = document.getElementById('chart-container');
  
  // Create SVG
  const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
  svg.setAttribute('width', '100%');
  svg.setAttribute('height', '100%');
  svg.setAttribute('viewBox', `0 0 ${chartWidth + margin.left + margin.right} ${chartHeight + margin.top + margin.bottom}`);
  svg.style.display = 'block';
  chartContainer.appendChild(svg);

  // Chart group
  const chartGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
  chartGroup.setAttribute('transform', `translate(${margin.left}, ${margin.top})`);
  svg.appendChild(chartGroup);

  // Process data - get unique categories and their values
  const dataByCategory = {};
  tableData.forEach(row => {
    const cat = row[categoryField];
    const val = parseFloat(row[valueField]) || 0;
    if (!dataByCategory[cat]) {
      dataByCategory[cat] = [];
    }
    dataByCategory[cat].push({
      value: val,
      color: colorField ? row[colorField] : null,
      originalRow: row
    });
  });

  const categories = Object.keys(dataByCategory);
  const allValues = Object.values(dataByCategory).flat().map(d => d.value);
  const maxValue = Math.max(...allValues);
  const minValue = Math.min(0, Math.min(...allValues));
  const valueRange = maxValue - minValue;
  
  console.log('üìä Data processed:', { categories: categories.length, maxValue, minValue });

  // Clean color palette
  const colors = ['#4285f4', '#34a853', '#ea4335', '#fbbc04', '#ff6d01', '#9aa0a6', '#ab47bc', '#00acc1'];

  // Calculate bar dimensions
  const barGroupWidth = chartWidth / categories.length * 0.8;
  const barGroupSpacing = chartWidth / categories.length * 0.2;

  // Render bars for each category
  categories.forEach((category, categoryIndex) => {
    const categoryData = dataByCategory[category];
    const numBars = categoryData.length;
    const barWidth = numBars > 1 ? barGroupWidth / numBars : barGroupWidth;
    
    categoryData.forEach((dataPoint, barIndex) => {
      const value = dataPoint.value;
      const barHeight = Math.abs(value - minValue) / valueRange * chartHeight;
      const barY = value >= 0 ? 
        chartHeight - barHeight : 
        chartHeight - (Math.abs(minValue) / valueRange * chartHeight);
      
      const barX = categoryIndex * (barGroupWidth + barGroupSpacing) + (barIndex * barWidth);
      
      // Choose color
      let barColor = colors[categoryIndex % colors.length];
      if (colorField && dataPoint.color) {
        // Use different shades for different color values
        const uniqueColors = [...new Set(tableData.map(r => r[colorField]).filter(Boolean))];
        const colorIndex = uniqueColors.indexOf(dataPoint.color);
        barColor = colors[colorIndex % colors.length];
      }

      // Create bar rectangle
      const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
      rect.setAttribute('x', barX);
      rect.setAttribute('y', barY);
      rect.setAttribute('width', barWidth - 2);
      rect.setAttribute('height', barHeight);
      rect.setAttribute('fill', barColor);
      rect.setAttribute('stroke', '#ffffff');
      rect.setAttribute('stroke-width', '1');
      rect.style.cursor = 'pointer';
      
      // Add hover effect
      rect.addEventListener('mouseenter', () => {
        rect.setAttribute('opacity', '0.8');
        showTooltip(category, value, dataPoint.color);
      });
      rect.addEventListener('mouseleave', () => {
        rect.setAttribute('opacity', '1');
        hideTooltip();
      });

      chartGroup.appendChild(rect);

      // Add value label on top of bar
      if (barHeight > 20) {
        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        text.setAttribute('x', barX + barWidth/2);
        text.setAttribute('y', barY - 5);
        text.setAttribute('text-anchor', 'middle');
        text.setAttribute('font-family', 'Segoe UI, sans-serif');
        text.setAttribute('font-size', '12');
        text.setAttribute('fill', '#5f6368');
        text.textContent = value.toLocaleString();
        chartGroup.appendChild(text);
      }
    });

    // Add category label
    const categoryLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    categoryLabel.setAttribute('x', categoryIndex * (barGroupWidth + barGroupSpacing) + barGroupWidth/2);
    categoryLabel.setAttribute('y', chartHeight + 20);
    categoryLabel.setAttribute('text-anchor', 'middle');
    categoryLabel.setAttribute('font-family', 'Segoe UI, sans-serif');
    categoryLabel.setAttribute('font-size', '14');
    categoryLabel.setAttribute('fill', '#202124');
    categoryLabel.textContent = category;
    chartGroup.appendChild(categoryLabel);
  });

  // Add Y-axis labels
  const numYTicks = 5;
  for (let i = 0; i <= numYTicks; i++) {
    const value = minValue + (valueRange * i / numYTicks);
    const y = chartHeight - (i / numYTicks * chartHeight);
    
    const tick = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    tick.setAttribute('x1', -5);
    tick.setAttribute('y1', y);
    tick.setAttribute('x2', 0);
    tick.setAttribute('y2', y);
    tick.setAttribute('stroke', '#dadce0');
    tick.setAttribute('stroke-width', '1');
    chartGroup.appendChild(tick);
    
    const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    label.setAttribute('x', -10);
    label.setAttribute('y', y + 4);
    label.setAttribute('text-anchor', 'end');
    label.setAttribute('font-family', 'Segoe UI, sans-serif');
    label.setAttribute('font-size', '12');
    label.setAttribute('fill', '#5f6368');
    label.textContent = Math.round(value).toLocaleString();
    chartGroup.appendChild(label);
  }

  // Add axis lines
  const xAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
  xAxis.setAttribute('x1', 0);
  xAxis.setAttribute('y1', chartHeight);
  xAxis.setAttribute('x2', chartWidth);
  xAxis.setAttribute('y2', chartHeight);
  xAxis.setAttribute('stroke', '#dadce0');
  xAxis.setAttribute('stroke-width', '2');
  chartGroup.appendChild(xAxis);

  const yAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
  yAxis.setAttribute('x1', 0);
  yAxis.setAttribute('y1', 0);
  yAxis.setAttribute('x2', 0);
  yAxis.setAttribute('y2', chartHeight);
  yAxis.setAttribute('stroke', '#dadce0');
  yAxis.setAttribute('stroke-width', '2');
  chartGroup.appendChild(yAxis);

  console.log('‚úÖ Clean bar chart rendered with', categories.length, 'categories');
}

// Simple tooltip functions
function showTooltip(category, value, color) {
  // Remove any existing tooltip
  hideTooltip();
  
  const tooltip = document.createElement('div');
  tooltip.id = 'bar-tooltip';
  tooltip.style.cssText = `
    position: fixed;
    background: rgba(0,0,0,0.8);
    color: white;
    padding: 8px 12px;
    border-radius: 4px;
    font-size: 12px;
    font-family: Segoe UI, sans-serif;
    pointer-events: none;
    z-index: 1000;
    box-shadow: 0 2px 8px rgba(0,0,0,0.2);
  `;
  
  let content = `<strong>${category}</strong><br/>Value: ${value.toLocaleString()}`;
  if (color) {
    content += `<br/>Color: ${color}`;
  }
  
  tooltip.innerHTML = content;
  document.body.appendChild(tooltip);
  
  // Position tooltip near mouse
  document.addEventListener('mousemove', updateTooltipPosition);
}

function hideTooltip() {
  const tooltip = document.getElementById('bar-tooltip');
  if (tooltip) {
    tooltip.remove();
    document.removeEventListener('mousemove', updateTooltipPosition);
  }
}

function updateTooltipPosition(e) {
  const tooltip = document.getElementById('bar-tooltip');
  if (tooltip) {
    tooltip.style.left = (e.clientX + 10) + 'px';
    tooltip.style.top = (e.clientY - 10) + 'px';
  }
}

// Initialize using the postMessage pattern that was actually working
function initVisualization() {
  console.log('üöÄ Initializing bar chart visualization...');
  
  // USE THE WORKING POSTMESSAGE PATTERN (same as test viz)
  console.log('üîß Setting up postMessage subscription...');

  // Listen for postMessage from parent window (this is the working pattern!)
  window.addEventListener('message', function(event) {
    console.log('üì® Received message from parent:', event);
    console.log('üìä Message data looks like:', event.data);
    if (event.data && typeof event.data === 'object') {
      console.log('üéâ Found data in message! Trying to visualize...');
      drawViz(event.data);
    }
  });

  // Signal to parent that we're ready
  console.log('üì° Signaling ready to parent window...');
  try {
    if (window.parent) {
      window.parent.postMessage({type: 'ready'}, '*');
    }
  } catch (e) {
    console.log('‚ö†Ô∏è Could not signal parent (normal in iframe)');
  }

  // Also try the new API if available, but don't rely on it
  if (window.google?.lookerstudio?.registerVisualization) {
    console.log('üîç Trying new Looker Studio API as backup...');
    try {
      // Try without objectTransform first (same as working test viz)
      window.google.lookerstudio.registerVisualization(drawViz);
      console.log('‚úÖ Registered with new API (no transform)');
    } catch (e) {
      console.log('‚ö†Ô∏è New API failed:', e.message);
    }
  }
  
  // Fallback: show test data after delay if no real data comes
  setTimeout(() => {
    const container = document.getElementById('container') || document.body;
    if (!container.innerHTML.trim()) {
      console.log('‚ö†Ô∏è No data received after 5 seconds - showing test bars');
      showTestBars();
    }
  }, 5000);
}

// Test bars fallback function
function showTestBars() {
  console.log('üß™ Showing test bars...');
  
  const testData = {
    dataResponse: {
      tables: [{
        id: "DEFAULT",
        fields: ["dimension", "metric"],
        rows: [
          ["Category A", "100"],
          ["Category B", "200"], 
          ["Category C", "150"],
          ["Category D", "300"]
        ]
      }]
    },
    fields: [
      {id: "dimension", name: "category", concept: "DIMENSION"},
      {id: "metric", name: "value", concept: "METRIC"}
    ]
  };
  
  drawViz(testData);
}

// Start when DOM is ready
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', initVisualization);
} else {
  initVisualization();
}

console.log('üìä Bar chart script loaded and ready!');
